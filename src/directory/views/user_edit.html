{% extends 'layout.html' %}
{% set current_tab = 'users' %}
{% block content %}
<div x-data="userEditPage()" x-init="init()" class="space-y-4">
  <h2 class="text-xl font-semibold text-gray-900">Edit User</h2>
  <div class="bg-white rounded-lg shadow p-6 space-y-4">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <input x-model="user.display_name" placeholder="Display Name" class="border rounded px-3 py-2" />
      <input x-model="user.email" placeholder="Primary Email" class="border rounded px-3 py-2" />
    </div>
    <div>
      <label class="block text-sm font-medium text-gray-700 mb-2">Roles</label>
      <div class="flex flex-wrap gap-2">
        <template x-for="role in roles" :key="role.id">
          <label class="inline-flex items-center gap-2 border rounded px-2 py-1">
            <input type="checkbox" :value="role.id" @change="toggleRole(role.id, $event.target.checked)"
              :checked="selectedRoles.includes(role.id)">
            <span x-text="role.name"></span>
          </label>
        </template>
      </div>
    </div>
    <div>
      <label class="block text-sm font-medium text-gray-700 mb-2">Groups</label>
      <div class="flex flex-wrap gap-2">
        <template x-for="group in groups" :key="group.id">
          <label class="inline-flex items-center gap-2 border rounded px-2 py-1">
            <input type="checkbox" :value="group.id" @change="toggleGroup(group.id, $event.target.checked)"
              :checked="selectedGroups.includes(group.id)">
            <span x-text="group.name"></span>
          </label>
        </template>
      </div>
    </div>
    <div>
      <div class="flex justify-between items-center mb-2">
        <label class="block text-sm font-medium text-gray-700">Custom Properties</label>
        <button @click="addProperty()" type="button" class="text-sm text-blue-600 hover:text-blue-700">+ Add
          Property</button>
      </div>
      <div class="space-y-2">
        <template x-for="(prop, index) in properties" :key="index">
          <div class="flex gap-2">
            <select x-model="prop.key" @change="onPropertyKeyChange(index, $event.target.value)"
              class="flex-1 border rounded px-2 py-1 text-sm">
              <option value="">Select Key...</option>
              <template x-for="stdKey in standardPropertyKeys" :key="stdKey.key">
                <option :value="stdKey.key" x-text="stdKey.key + ' - ' + stdKey.description"></option>
              </template>
              <option value="__custom__">Custom Key...</option>
            </select>
            <input x-show="prop.key === '__custom__'" x-model="prop.customKey" placeholder="Custom Key"
              class="flex-1 border rounded px-2 py-1 text-sm" />
            <input x-model="prop.value" placeholder="Value" class="flex-1 border rounded px-3 py-2 text-sm" />
            <button @click="removeProperty(index)" type="button" class="text-red-600 hover:text-red-700 px-2">Ã—</button>
          </div>
        </template>
        <template x-if="properties.length === 0">
          <p class="text-sm text-gray-500 italic">No custom properties defined</p>
        </template>
      </div>
    </div>
    <div x-show="error" class="mb-3 p-3 bg-red-50 border border-red-200 rounded text-red-600 text-sm" x-text="error">
    </div>
    <div class="flex justify-end gap-2">
      <a href="/" class="px-4 py-2 border rounded">Cancel</a>
      <button @click="save()" class="px-4 py-2 bg-blue-600 text-white rounded">Save</button>
    </div>
  </div>
</div>
<script>
  function userEditPage() {
    const userId = new URLSearchParams(window.location.search).get('id');

    // Fallback fetch function if csrfFetch is not available
    const safeFetch = window.csrfFetch || fetch.bind(window);

    return {
      user: {}, roles: [], groups: [], selectedRoles: [], selectedGroups: [], properties: [], standardPropertyKeys: [], error: null,
      async init() {
        await this.loadPropertyKeys();
        try {
          const uRes = await safeFetch(`/api/users/${userId}`);
          if (!uRes.ok) {
            this.error = 'Failed to load user data';
            console.error(`User fetch failed with status ${uRes.status}`);
            return;
          }
          const u = await uRes.json();
          this.user = u;
          this.selectedRoles = (u.roles || []).map(r => r.id);
          this.selectedGroups = (u.groups || []).map(g => g.id);

          // Load properties
          if (u.properties && Array.isArray(u.properties)) {
            this.properties = u.properties.map(p => {
              // Check if it's a standard key
              const isStandard = this.standardPropertyKeys.some(sk => sk.key === p.key);
              return {
                key: isStandard ? p.key : '__custom__',
                customKey: isStandard ? '' : p.key,
                value: p.value
              };
            });
          }

          const rolesRes = await safeFetch('/api/roles');
          if (rolesRes.ok) {
            this.roles = await rolesRes.json();
          }

          const groupsRes = await safeFetch('/api/groups');
          if (groupsRes.ok) {
            this.groups = await groupsRes.json();
          }
        } catch (err) {
          this.error = 'Failed to load user data';
          console.error('Error loading user data:', err);
        }
      },
      async loadPropertyKeys() {
        try {
          const resp = await safeFetch('/api/property-keys/standard');
          if (resp.ok) {
            this.standardPropertyKeys = await resp.json();
          }
        } catch (err) {
          console.error('Error loading property keys:', err);
        }
      },
      addProperty() {
        this.properties.push({ key: '', customKey: '', value: '' });
      },
      removeProperty(index) {
        this.properties.splice(index, 1);
      },
      onPropertyKeyChange(index, value) {
        if (value !== '__custom__') {
          this.properties[index].customKey = '';
        }
      },
      toggleRole(id, on) { if (on) { if (!this.selectedRoles.includes(id)) this.selectedRoles.push(id); } else { this.selectedRoles = this.selectedRoles.filter(x => x !== id); } },
      toggleGroup(id, on) { if (on) { if (!this.selectedGroups.includes(id)) this.selectedGroups.push(id); } else { this.selectedGroups = this.selectedGroups.filter(x => x !== id); } },
      async save() {
        this.error = null;
        try {
          const payload = {
            display_name: this.user.display_name,
            email: this.user.email,
            role_ids: this.selectedRoles,
            group_ids: this.selectedGroups,
            properties: this.properties.filter(p => {
              const key = p.key === '__custom__' ? p.customKey : p.key;
              return key && key.trim() !== '';
            }).reduce((acc, p) => {
              const key = p.key === '__custom__' ? p.customKey.trim() : p.key.trim();
              acc[key] = p.value;
              return acc;
            }, {})
          };
          const r = await safeFetch(`/api/users/${userId}`, { method: 'PATCH', body: JSON.stringify(payload) });
          if (r.ok) { window.location.href = '/'; }
          else {
            // Try to parse JSON response for detailed error message
            let errorMessage = 'Failed to update user';
            const contentType = r.headers.get('content-type');

            if (contentType && contentType.includes('application/json')) {
              try {
                const err = await r.json();
                errorMessage = err.error || `Server error: ${r.status}`;
              } catch (parseErr) {
                errorMessage = `Server error (${r.status}): Invalid response`;
              }
            } else {
              // Provide status-specific error messages for non-JSON responses
              if (r.status === 400) {
                errorMessage = 'Invalid request data';
              } else if (r.status === 401 || r.status === 403) {
                errorMessage = 'Not authorized to update user';
              } else if (r.status === 404) {
                errorMessage = 'User not found';
              } else if (r.status === 409) {
                errorMessage = 'Email already in use';
              } else if (r.status >= 500) {
                errorMessage = 'Server error - please try again later';
              } else {
                errorMessage = `Request failed (${r.status})`;
              }
            }
            this.error = errorMessage;
          }
        } catch (err) {
          this.error = 'Network error occurred';
          console.error('Error saving user:', err);
        }
      }
    }
  }
</script>
{% endblock %}